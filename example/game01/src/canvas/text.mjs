import {referTex, registerTex, setMutableGlTex, assignAndUploadGlTex, referGlTexIdx, referGlTexIdxOrUpload0} from './gl/texture.mjs'


// hard tabは非対応の仕様


// TODO: 日本語の禁則処理込みの自動改行処理を適用できるようにする
//       (とりあえず旧bankerのものをこのモジュール末尾に持ってきた)
//       ただ、これについては canvas/text.mjs に入れるのではなく
//       text/word-wrap-ja.mjs とかを作って、そっちに入れて、
//       それを参照するようにした方がいいと思う。
//       また現状だと自動改行を扱うオプションがそもそも入ってないので、
//       まずそこから入れる必要がある。


// TODO: ※生成時オプションのfontResolutionを廃止し、代わりに
//       「完成時のcanvasサイズ(の上限)」を指定できるようにする。
//       ※これはop0078で対応する事！
//       - これにより、WebGLで安全に扱えるtextureの最低保証サイズ上限(2048)
//         以内である事を確実に保証できる。taへの追加も安全にできる
//       - fontResolutionの情報自体は生成時に必要だが、
//         「完成時のcanvasサイズ(の上限)」が分かっていれば、そこから
//         適切なfontResolutionを算出できる為
//         - (canvas.height - paddingTop - paddingBottom) / 行数 / lineHeightRatio = FontResolution になる筈
//       - 将来にword-wrapに対応する場合、こちらの方が必要な情報が自動的に揃う
//       - (実際の描画時は置いておいて)生成時タイミングでは
//         アスペクト比を維持すべきなので、指定サイズの縦もしくは横のどちらかが
//         指定サイズよりも小さくなる想定。ただ指定サイズよりも大きくなる事は
//         絶対にない(これでta反映を安全にしている)
//       - 行数を固定にするユーティリティを提供した方がいい。
//         (これは今はwidgetに入っているがtext/util.mjsあたりに入れておきたい)
//         行数が変動する場合、前述のfontResolutionも変動してしまうが、
//         用途によって、それが良い場合と、そうでない場合とがある為。
//         これの制御は呼び出し元でした方がよいと思う



// lineHeight(lineHeightRatioから算出される値)は文字上部に余白を作るように
// 機能しているが、これはlineHeightの役割として「複数行テキストの行間を空ける」
// 以外に、「テキストのbaseline下の余白と文字上の余白のバランスを取る」
// 役目も兼ねている為。もしこれが困る場合、バランス取りの方は
// margin系パラメータで調整するとよい。


// TODO: alphaを適切に設定できるよう、描画処理を改善する？うーん…


const defaultOptions = {
  ctx2dProps: {
    textBaseline: "top",
    fillStyle: "#0FF", // character color and so on
    strokeStyle: "#F00", // character outline color and so on
    miterLimit: 3,
  },
  align: "left", // "left" or "center" or "right"
  fontResolution: 48, // px (it affects fontSize, but it is resolution actually)
  //fontFamily: "'Courier New', serif",
  fontFamily: "Courier, serif",
  //fontMisc: "italic bold", // set if needed
  //willUpdateFrequently: true, // set it for optimize
  lineHeightRatio: 1.2, // ratio by fontResolution
  strokeWidthRatio: 0.4, // ratio by fontResolution
  //marginRatioLeft: undefined, // ratio by fontResolution
  //marginRatioRight: undefined, // ratio by fontResolution
  //marginRatioTop: undefined, // ratio by fontResolution
  //marginRatioBottom: undefined, // ratio by fontResolution
  marginRatioFallback: 0.1, // ratio by fontResolution
  //bgStyle: "rgba(127, 127, 127, 0.5)", // useful for debug
  //trimCanvas: false, // trim empty canvas area, but heavy
  canvasSizeLimit: 2048, // これより大きくなる場合は制限する(2048はWebGL2の安全サイズ限界)
  //dropshadowStyle: "#000", // NB: これはalphaを設定しない方がよい
  dropshadowAdjustRatioX: -0.1, // ratio by fontResolution
  dropshadowAdjustRatioY: -0.1, // ratio by fontResolution
};

const makeContext = (canvas) => canvas.getContext("2d", {willReadFrequently: !!canvas._options.trimCanvas});


export const makeTextCanvas = (options={}, initialLabel=undefined) => {
  const canvas = document.createElement('canvas');
  const ctx2dProps = { ... defaultOptions.ctx2dProps, ... options.ctx2dProps };
  canvas._options = { ... defaultOptions, ... options, ctx2dProps };
  canvas._semaphore = 0;
  canvas._waitingResolvers = [];
  if (options.willUpdateFrequently) { canvas._ctx = makeContext(canvas) }
  if (initialLabel != null) { updateTextCanvas(canvas, initialLabel) }
  return canvas;
};


let autoGeneratedCounter = 100000;
// NB: dotに埋め込める版のmakeTextCanvas。
//     これは仕様上asyncにできないので重く、
//     (最初のtickDot時にisAutoGlobalW/Hの計算が走るがその時点でcanvas必須)
//     dot生成時にその重さがそのまま加算される！要注意
export const makeTextCanvasAndRegisteredTexId = (gl, options, initialLabel) => {
  const id = "canvas/text/ag" + autoGeneratedCounter++;
  const canvas = makeTextCanvas(options, initialLabel);
  registerTex(gl, id, canvas);
  return id;
};


const applyStyle = (ctx, o) => {
  const ctx2dProps = o.ctx2dProps;
  Object.keys(ctx2dProps).forEach((k)=> ctx[k] = ctx2dProps[k]);
  const fontResolution = o.fontResolution;
  const lineHeight = o.lineHeightRatio * fontResolution;
  ctx.font = `${o.fontMisc??''} ${fontResolution}px/${lineHeight}px ${o.fontFamily}`;
  const strokeWidth = o.strokeWidthRatio * fontResolution;
  ctx.lineWidth = strokeWidth;
  ctx.textAlign = o.align;
};

const countSpaces = (spacesStr) => spacesStr.split('').map((c)=>((c===' ') ? 1 : (c==="　") ? 2 : 0)).reduce(((acc, v)=> acc + v), 0);

const trimSpacesFromLine = (line) => {
  const [_, preSpaces, trimmedLine, postSpaces] = line.match(/^([ 　]*)(.*?)([ 　]*)$/);
  // 半角スペース換算の前後の空白の個数(全角スペースは2個換算)
  const preSpacesCount = countSpaces(preSpaces);
  const postSpacesCount = countSpaces(postSpaces);
  // 前後の空白が除去されたline
  return [trimmedLine, preSpacesCount, postSpacesCount];
};


const hasPixelInRow = (d, canvasW, y) => {
  for (let x = 0; x < canvasW; x++) {
    // [x, y]ピクセルのalphaが0かどうかを見る
    if (d[(canvasW*y + x)*4 + 3]) { return 1 }
  }
  return 0;
};

const hasPixelInCol = (d, canvasW, canvasH, x) => {
  for (let y = 0; y < canvasH; y++) {
    // [x, y]ピクセルのalphaが0かどうかを見る
    if (d[(canvasW*y + x)*4 + 3]) { return 1 }
  }
  return 0;
};

const trimCanvas = (canvas, ctx, canvasW, canvasH, paddingLeft, paddingRight, paddingTop, paddingBottom) => {
  // padding最低保証
  paddingLeft = Math.max(paddingLeft, 1);
  paddingRight = Math.max(paddingRight, 1);
  paddingTop = Math.max(paddingTop, 1);
  paddingBottom = Math.max(paddingBottom, 1);
  const d = ctx.getImageData(0, 0, canvasW, canvasH).data;
  // TODO: ここは関数化とかでもうちょっと共通化できない？
  // topMargin算出
  let topMargin = 0;
  while (1) {
    if (canvasH <= topMargin) { break }
    if (hasPixelInRow(d, canvasW, topMargin)) { break }
    topMargin++;
  }
  // bottomMargin算出
  let bottomMargin = 0;
  while (1) {
    if (canvasH - topMargin <= bottomMargin) { break }
    if (hasPixelInRow(d, canvasW, canvasH - bottomMargin - 1)) { break }
    bottomMargin++;
  }
  // leftMargin算出
  let leftMargin = 0;
  while (1) {
    if (canvasW <= leftMargin) { break }
    if (hasPixelInCol(d, canvasW, canvasH, leftMargin)) { break }
    leftMargin++;
  }
  // rightMargin算出
  let rightMargin = 0;
  while (1) {
    if (canvasW - leftMargin <= rightMargin) { break }
    if (hasPixelInCol(d, canvasW, canvasH, canvasW - rightMargin - 1)) { break }
    rightMargin++;
  }
  // marginを削った残り領域データを退避する
  const resultW = canvasW - leftMargin - rightMargin;
  const resultH = canvasH - topMargin - bottomMargin;
  const storedArray = new Uint8ClampedArray(ctx.getImageData(leftMargin, topMargin, resultW, resultH).data);
  // canvasを縮めると同時にクリアする
  canvas.width = paddingLeft + resultW + paddingRight;
  canvas.height = paddingTop + resultH + paddingBottom;
  // 退避したデータを復元する
  const imageData = new ImageData(storedArray, resultW, resultH);
  ctx.putImageData(imageData, paddingLeft, paddingTop);
};


export const updateTextCanvas = (canvas, text) => {
  // race conditionにより文字列が同じになっていたら、処理をスキップする
  if (canvas._oldText === text) { return }
  canvas._oldText = text;
  // TODO: 特定の横幅指定かつ日本語の禁則処理で自動改行するモードをつける
  const lines = text.split(/(?:\r\n|\r|\n)/);
  const ctx = canvas._ctx || makeContext(canvas);
  const o = canvas._options;
  const align = o.align;
  const fontResolution = o.fontResolution;
  const lineHeight = o.lineHeightRatio * fontResolution;
  const strokeWidth = o.strokeWidthRatio * fontResolution;
  const marginRatioFallback = o.marginRatioFallback;
  const marginRatioLeft = o.marginRatioLeft ?? marginRatioFallback;
  const marginRatioRight = o.marginRatioRight ?? marginRatioFallback;
  const marginRatioTop = o.marginRatioTop ?? marginRatioFallback;
  const marginRatioBottom = o.marginRatioBottom ?? marginRatioFallback;
  const marginLeft = Math.round(marginRatioLeft * fontResolution + strokeWidth);
  const marginRight = Math.round(marginRatioRight * fontResolution + strokeWidth);
  const marginTop = Math.round(marginRatioTop * fontResolution + strokeWidth);
  const marginBottom = Math.round(marginRatioBottom * fontResolution + strokeWidth);
  applyStyle(ctx, o);
  // canvasのサイズを求め、適用する
  const metricMaxW = Math.max(... lines.map((line)=>{
    const [trimmedLine, preSpacesCount, postSpacesCount] = trimSpacesFromLine(line);
    return ((preSpacesCount + postSpacesCount) * fontResolution / 2) + ctx.measureText(trimmedLine).width;
  }));
  const spaceW = ctx.measureText("M MM").width/4;
  const canvasW = Math.min(o.canvasSizeLimit, Math.max(1, Math.round(marginLeft + metricMaxW + marginRight)));
  const canvasH = Math.min(o.canvasSizeLimit, Math.max(1, Math.round(marginTop + lineHeight*lines.length + marginBottom)));
  canvas.width = canvasW;
  canvas.height = canvasH;
  // canvas背景の処理
  if (o.bgStyle) {
    ctx.fillStyle = o.bgStyle;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  } else {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
  applyStyle(ctx, o);
  let adjustX = 0;
  let adjustY = 0;
  const processAllRows = (drawFn) => {
    for (let row = 0; row < lines.length; row++) {
      const [trimmedLine, preSpacesCount, postSpacesCount] = trimSpacesFromLine(lines[row]);
      let x =
        (align === 'left') ? (marginLeft + preSpacesCount*spaceW) :
        (align === 'right') ? (canvasW - marginRight - postSpacesCount*spaceW) :
        ((canvasW + marginLeft - marginRight) + (preSpacesCount - postSpacesCount)*spaceW)/2;
      const y = marginTop + lineHeight*row + (lineHeight - fontResolution)/2;
      drawFn(trimmedLine, x + adjustX, y + adjustY);
    }
  };
  const dsStyle = o.dropshadowStyle;
  if (dsStyle) {
    // style設定をdropshadow用に上書きする
    const dsO = { ... o };
    dsO.ctx2dProps = { ... o.ctx2dProps };
    dsO.ctx2dProps.fillStyle = dsStyle;
    dsO.ctx2dProps.strokeStyle = dsStyle;
    applyStyle(ctx, dsO);
    // dropshadowを一行ずつ処理していく
    const dsAdjustX = o.dropshadowAdjustRatioX * fontResolution;
    const dsAdjustY = o.dropshadowAdjustRatioY * fontResolution;
    adjustX = dsAdjustX;
    adjustY = dsAdjustY;
    processAllRows((line, x, y) => ctx.strokeText(line, x, y));
    processAllRows((line, x, y) => ctx.fillText(line, x, y));
    // style設定を元に戻す
    applyStyle(ctx, o);
    adjustX = -dsAdjustX;
    adjustY = -dsAdjustY;
  }
  // アウトラインを一行ずつ処理していく
  processAllRows((line, x, y) => ctx.strokeText(line, x, y));
  // 文字本体を一行ずつ処理していく
  processAllRows((line, x, y) => ctx.fillText(line, x, y));
  // 必要ならtrimCanvasする
  if (o.trimCanvas) { trimCanvas(canvas, ctx, canvasW, canvasH, marginLeft, marginRight, marginTop, marginBottom) }
};


export const updateTextCanvasAsync = (canvas, text) => {
  // 文字列が同じなら何もしない
  if (canvas._oldText === text) {
    return new Promise((resolve, _) => resolve());
  }
  canvas._semaphore++;
  return new Promise((resolve, reject) => {
    const thunk = () => {
      canvas._semaphore--;
      // この後に別のupdateTextCanvasAsync予約があるなら、先の方は処理しない。
      // 後の方が完了してからresolve()だけ実行する
      if (canvas._semaphore) { return canvas._waitingResolvers.push(resolve) }
      updateTextCanvas(canvas, text);
      // 完了を通知する
      resolve();
      // 他にも完了待ちresolverがあるなら、それも完了させる
      canvas._waitingResolvers.forEach((resolve)=>resolve());
      canvas._waitingResolvers = [];
    };
    // TODO: ここをオフスクリーンレンダリングにできるとより良いが…
    setTimeout(thunk, 0);
  });
};


// TODO: 以下は旧bankerのwordWrap処理
//;;; See http://ja.wikipedia.org/wiki/%E7%A6%81%E5%89%87%E5%87%A6%E7%90%86
//
//;;; 禁則処理のルール：
//;;; - 以下の文字が行頭になるような行分割をしてはいけない
//(def ^:private forbidden-head-chars
//  (set (str ",，.．)）]］}｝"
//            "〕〉》」』】≫"
//            "〟`'’\"”"
//            "、。"
//            "ゝゞーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎ々"
//            "‐・～"
//            "?？!！"
//            ":：;；/／"
//            "…‥"
//            )))
//;;; - 以下の文字が行末になるような行分割をしてはいけない
//(def ^:private forbidden-tail-chars
//  (set (str "(（[［{｛"
//            "〔〈《「『【≪"
//            "〝`'‘\"“"
//            "…‥"
//            "$＄\\￥" ; 通貨記号として
//            )))
//;;; - 英単語や数字の途中で行分割をしてはいけない
//(def ^:private alphabet-chars
//  (set (str "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
//            "abcdefghijklmnopqrstuvwxyz"
//            "@_"
//            "0123456789-."
//            )))
//;;;   - ただし、1単語がmax-widthを越える場合は仕方がないので
//;;;     例外的に分割するものとする
//
//(defn- tokenize-line-ja [line]
//  (if (empty? line)
//    nil
//    (loop [result nil
//           prev-acc (first line)
//           left-chars (rest line)]
//      (if (empty? left-chars)
//        (reverse (cons prev-acc result))
//        (let [prev-char (last prev-acc)
//              current-char (first left-chars)
//              next-chars (rest left-chars)
//              must-join? (or
//                           (forbidden-tail-chars prev-char)
//                           (forbidden-head-chars current-char)
//                           (and
//                             (alphabet-chars prev-char)
//                             (alphabet-chars current-char)))]
//          (if must-join?
//            (recur result (str prev-acc current-char) next-chars)
//            (recur (cons prev-acc result) current-char next-chars)))))))
//
//
//
//;;; いい感じになるように、一度分解されたtokensから複数の行を構成する
//(defn- compose-lines [ctx max-width tokens]
//  (if (empty? tokens)
//    nil
//    (loop [result nil
//           prev-acc ""
//           left-tokens tokens]
//      ;; NB: left-tokensが空になった時、prev-accには必ず何か入っている
//      ;;     (prev-accが空になるのはmax-widthの範囲を越えた時だけで、
//      ;;     その時はleft-tokensを消費しないので、何かしら残っている事が
//      ;;     保証されている)
//      (if (empty? left-tokens)
//        (reverse (cons prev-acc result))
//        (let [current-acc (str prev-acc (first left-tokens))
//              ;; 最終的には各行はtrimにかけられるので、
//              ;; 長さを測定するのもtrimのかかった状態で行った方がよい。
//              ;; ただし元文字列の先頭の空白は除去してはならない！
//              stripped-current-acc (if (nil? result)
//                                     (string/trimr current-acc)
//                                     (string/trim current-acc))
//              current-width (.-width (.measureText ctx stripped-current-acc))]
//          (vm/cond*
//            ;; まだ範囲内。次の文字を取り込めないか試す。
//            [(<= current-width max-width)
//             (recur result current-acc (rest left-tokens))]
//            ;; 普通に範囲を越えた。直前の状態を結果に追加して次の行へ。
//            [(not= "" prev-acc)
//             (recur (cons prev-acc result) "" left-tokens)]
//            ;; token一つで既にmax-widthを越えている。強制的に分割する。
//            [:else
//             (let [sub-lines (if (= 1 (count current-acc))
//                               current-acc
//                               (compose-lines ctx max-width current-acc))
//                   result-lines (drop-last sub-lines)
//                   last-line (last sub-lines)
//                   new-result (concat (reverse result-lines) result)]
//               (recur new-result last-line (rest left-tokens)))]))))))
//
//
//
//;;; 適切に改行を行う。
//;;; また、改行の前後に半角空白文字がある場合、それを除去する。
//(defn- word-wrap-line-ja [ctx max-width line]
//  (let [tokens (tokenize-line-ja line) ; 改行挿入可能な最小単位に分割
//        lines (compose-lines ctx max-width tokens) ; tokensから複数の行を構成
//        ;; 各行の行先頭と行末尾の空白を除去する。
//        ;; ただし元文字列の先頭の空白は除去してはならない！
//        lines (if (empty? lines)
//                lines
//                (cons
//                  (string/trimr (first lines))
//                  (map string/trim (rest lines))))]
//    (string/join "\n" lines)))






// TODO: (優先度低)オフスクリーンcanvas対応
//       transferControlToOffscreen が生えているかをチェックし、生えてるなら
//       今setTimeoutで後で実行している部分をWebWorkersで実行する
//       https://ics.media/entry/19043/
//       https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas
//       ただしiOSでの対応は2023/04からなので、後にしても問題ない


// TODO: (優先度低)leonsans(的なフォントデータ)への対応
//       https://github.com/cmiscm/leonsans


